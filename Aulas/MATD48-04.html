<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Fundamentos de Análise para Planejamento Experimental</title>
    <meta charset="utf-8" />
    <meta name="author" content="Raydonal Ospina" />
    <script src="libs/header-attrs-2.29/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/metropolis.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/metropolis-fonts.css" rel="stylesheet" />
    <link href="libs/htmltools-fill-0.5.8.1/fill.css" rel="stylesheet" />
    <script src="libs/htmlwidgets-1.6.4/htmlwidgets.js"></script>
    <script src="libs/viz-1.8.2/viz.js"></script>
    <link href="libs/DiagrammeR-styles-0.2/styles.css" rel="stylesheet" />
    <script src="libs/grViz-binding-1.0.11/grViz.js"></script>
    <link rel="stylesheet" href="custom-styles.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Fundamentos de Análise para Planejamento Experimental
]
.subtitle[
## Noções de Modelos Lineares para Planejamento experimental
]
.author[
### Raydonal Ospina
]

---





class: center, middle, inverse

# 1. Fundamentos e Estrutura de Modelos Lineares

(Seções 3.1 a 3.5)

---

## Modelos Lineares Estatísticos

Modelos lineares estatísticos são a espinha dorsal da análise de dados experimentais. Eles nos permitem modelar a relação entre uma variável de resposta e um ou mais fatores ou variáveis preditoras.

.pull-left[
**Estrutura Matemática Geral:**

$$ Y = \beta_0 + \beta_1 X_1 + \dots + \beta_p X_p + \epsilon $$

- **Componente Determinístico:** `\(\beta_0 + \beta_1 X_1 + \dots + \beta_p X_p\)`. Descreve a relação *média* entre Y e os X's.
- **Componente Estocástico:** `\(\epsilon\)`. Representa a variabilidade aleatória não explicada pelo modelo, incluindo erros de medição e variação biológica/natural.
]
.pull-right[
&lt;img src="MATD48-04_files/figure-html/unnamed-chunk-1-1.png" style="display: block; margin: auto;" /&gt;
]

---

## 3.1 Relações entre Fatores

Em um experimento, um **fator** particiona a população em grupos (seus **níveis**). A complexidade e a validade de um modelo dependem crucialmente de como os múltiplos fatores se relacionam.

--

As possíveis relações são:

1.  **Embutimento (Aninhamento):** Uma relação hierárququica.
2.  **Cruzamento:** Uma relação fatorial completa.
3.  **Confundimento:** Uma falha de delineamento onde os efeitos são indistinguíveis.

Compreender essas relações é o primeiro passo para construir um modelo estatístico correto.

---

## Fatores Embutidos (Aninhados)

Um fator `B` é dito estar **embutido** (ou aninhado) em um fator `A` se cada nível do fator `B` ocorre em combinação com apenas **um** nível do fator `A`.

### Exemplo Simulado: `Turma` aninhada em `Escola`


``` r
set.seed(321)
dados_aninhados &lt;- data.frame(
  Escola = factor(rep(c("Escola A", "Escola B", "Escola C"), each = 10)),
  # A Turma 'T1' da Escola A é diferente da Turma 'T1' da Escola B
  Turma = factor(rep(c("A.T1", "A.T2", "B.T1", "B.T2", "C.T1", "C.T2"), each = 5)),
  Nota = round(c(rnorm(5, 85, 4), rnorm(5, 82, 4), # Turmas da Escola A
                 rnorm(5, 75, 5), rnorm(5, 78, 5), # Turmas da Escola B
                 rnorm(5, 80, 3), rnorm(5, 79, 3)), 1) # Turmas da Escola C
)
```

**Implicação no Modelo:** O efeito de `Turma` deve ser modelado *dentro* do efeito de `Escola`. Um modelo aditivo `Nota ~ Escola + Turma` estaria **incorreto**. O modelo correto em R é `Nota ~ Escola / Turma`.

---

### Visualizando Dados Aninhados

Um boxplot revela a estrutura hierárquica. Vemos a variação entre turmas *dentro* de cada escola, e a variação entre as escolas.


``` r
ggplot(dados_aninhados, aes(x = Turma, y = Nota, fill = Escola)) +
  geom_boxplot() +labs(title = "Visualização de Dados Aninhados",
       subtitle = "Variação de Notas por Turma dentro de cada Escola",
       x = "Turmas (identidade única dentro de cada escola)",
       y = "Nota") + theme_minimal(base_size = 14) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

&lt;img src="MATD48-04_files/figure-html/unnamed-chunk-3-1.png" style="display: block; margin: auto;" /&gt;

**Interpretação Gráfica:** A comparação principal é entre Escolas. A comparação entre "A.T1" e "B.T1" não é direta, pois são populações de alunos diferentes em contextos diferentes.

---

## Fatores Cruzados

Dois fatores `A` e `B` são ditos **cruzados** quando cada nível de `A` ocorre em combinação com **todos** os níveis de `B`.

### Exemplo Simulado: `Droga` x `Dieta`


``` r
set.seed(456)
dados_cruzados &lt;- data.frame(
  Droga = factor(rep(c("Droga A", "Droga B"), each = 10)),
  Dieta = factor(rep(c("Normal", "Hipercalórica"), times = 2, each = 5)),
  Resposta = round(c(rnorm(5, 50, 8), rnorm(5, 52, 8), # Droga A
                     rnorm(5, 60, 8), rnorm(5, 40, 8)), 1) # Droga B
)
```
**Implicação no Modelo:** Permite estimar **efeitos principais** e a **interação**. O modelo em R é `Resposta ~ Droga * Dieta`.

---

### Visualizando Dados Cruzados: Efeitos Principais

Boxplots são ótimos para visualizar os efeitos principais de cada fator. Podemos visualizar o efeito principal de cada fator separadamente
.pull-left[

``` r
ggplot(dados_cruzados, aes(x = Droga, y = Resposta, fill = Droga)) +
  geom_boxplot() + labs(title = "Efeito Principal da Droga") +
  theme_minimal(base_size = 12) + theme(legend.position = "none")
```

&lt;img src="MATD48-04_files/figure-html/unnamed-chunk-5-1.png" style="display: block; margin: auto;" /&gt;
]
.pull-right[

``` r
ggplot(dados_cruzados, aes(x = Dieta, y = Resposta, fill = Dieta)) +
  geom_boxplot() + labs(title = "Efeito Principal da Dieta") +
  theme_minimal(base_size = 12) + theme(legend.position = "none")
```

&lt;img src="MATD48-04_files/figure-html/unnamed-chunk-6-1.png" style="display: block; margin: auto;" /&gt;
]

---

### Visualizando Dados Cruzados: Interação

Um gráfico de interação (ou de perfis) é a melhor ferramenta para visualizar se os efeitos são aditivos ou se interagem. Isso mostra o efeito médio de um fator, ignorando (ou agregando sobre) os níveis do outro. Corresponde conceitualmente às linhas "Droga" e "Dieta" na tabela de ANOVA.



``` r
ggplot(dados_cruzados, aes(x = Droga, y = Resposta, color = Dieta, group = Dieta)) +
  stat_summary(fun = mean, geom = "point", size = 4) +
  stat_summary(fun = mean, geom = "line", linewidth = 1.5) +
  labs(title = "Gráfico de Interação: Droga x Dieta",
       subtitle = "Linhas não paralelas sugerem interação",
       y = "Resposta Média") + theme_minimal(base_size = 14)
```

&lt;img src="MATD48-04_files/figure-html/unnamed-chunk-7-1.png" style="display: block; margin: auto;" /&gt;

**Interpretação Gráfica:** As linhas se cruzam! O efeito da Droga B é positivo na dieta Normal, mas negativo na Hipercalórica. Isso é uma **interação qualitativa** forte. Um modelo sem o termo de interação falharia em capturar essa dinâmica crucial.

---

class: center, middle, inverse

## 3.2 e 3.3: A Linguagem dos Diagramas de Hasse: Da Estrutura ao Modelo

---

### Aprofundando: O que é um Diagrama de Hasse?

Um Diagrama de Hasse é a representação gráfica de um **conjunto parcialmente ordenado (poset)**. No nosso contexto:
- **O conjunto:** É composto pelos fatores do modelo, mais a média geral (`\(\mu\)`) e o termo de erro residual (`\(\epsilon\)`).
- **A relação de ordem (`\(\preceq\)`):** É definida pela **relação de aninhamento**. Dizemos que `\(B \preceq A\)` ("B precede ou é igual a A") se o fator B está aninhado no (ou é contido pelo) fator A.

O diagrama simplifica a visualização desta ordem, mostrando apenas as relações de "cobertura" (se `\(B \preceq A\)` e não existe um C tal que `\(B \preceq C \preceq A\)`, então desenhamos uma linha de B para A). A direção da hierarquia é implícita (de baixo para cima).

### Por que isso é fundamental?
A estrutura de ordem parcial do diagrama dita diretamente:
1.  Quais termos são permitidos no modelo estatístico.
2.  Quais médias são "admissíveis" para cálculo e interpretação.
3.  Como a Soma de Quadrados deve ser particionada na ANOVA.

---

### A Gramática Visual dos Diagramas de Hasse

Para usar o diagrama, precisamos entender sua linguagem.

.pull-left[
**1. Aninhamento (Hierarquia)**
- **Relação:** Fator `B` está aninhado em `A` (`\(A \supset B\)`).
- **Visual:** Uma linha vertical direta conectando `B` (embaixo) a `A` (em cima).
<div class="grViz html-widget html-fill-item" id="htmlwidget-4977ff18aa131d4a57a1" style="width:576px;height:180px;"></div>
<script type="application/json" data-for="htmlwidget-4977ff18aa131d4a57a1">{"x":{"diagram":"digraph { node[shape=circle]; edge[arrowhead=none]; B -> A }","config":{"engine":"dot","options":null}},"evals":[],"jsHooks":[]}</script>
- **Interpretação:** O efeito de `B` só pode ser avaliado *dentro* dos níveis de `A`.
]
.pull-right[
**2. Cruzamento (Fatorial)**
- **Relação:** Fatores `A` e `B` são cruzados (`\(A \times B\)`).
- **Visual:** Estrutura paralela. Ambos partem de um nó superior comum e chegam a um nó inferior comum.
<div class="grViz html-widget html-fill-item" id="htmlwidget-256a5de20eef6003530f" style="width:576px;height:180px;"></div>
<script type="application/json" data-for="htmlwidget-256a5de20eef6003530f">{"x":{"diagram":"digraph { node[shape=circle]; edge[arrowhead=none]; E -> {A B} -> M }","config":{"engine":"dot","options":null}},"evals":[],"jsHooks":[]}</script>
- **Interpretação:** Os efeitos de `A`, `B` e da interação `A:B` podem ser estimados.
]

---

### Do Diagrama de Hasse para a Fórmula do Modelo em R

**Esta é a conexão mais importante:** O diagrama de Hasse é um mapa visual que se traduz diretamente na sintaxe de fórmulas do R.

.pull-left[
**1. Aninhamento (Hierarquia)**

O diagrama mostra `B` aninhado em `A`.

<div class="grViz html-widget html-fill-item" id="htmlwidget-6898bd41d61acf4f57f5" style="width:576px;height:180px;"></div>
<script type="application/json" data-for="htmlwidget-6898bd41d61acf4f57f5">{"x":{"diagram":"\ndigraph hierarchy {\n  rankdir=TB;\n  node [shape=circle, style=filled, fillcolor=lightblue];\n  edge [arrowhead=none];\n  B -> A;\n}\n","config":{"engine":"dot","options":null}},"evals":[],"jsHooks":[]}</script>

**Tradução para R:** O operador de aninhamento é `/`.
O modelo para o efeito de `B` aninhado em `A` é:
`~ A / B`
que é expandido pelo R para:
`~ A + A:B`
]
.pull-right[
**2. Cruzamento (Fatorial)**

O diagrama mostra `A` e `B` cruzados.

<div class="grViz html-widget html-fill-item" id="htmlwidget-1df8226eb962f6c00b56" style="width:576px;height:180px;"></div>
<script type="application/json" data-for="htmlwidget-1df8226eb962f6c00b56">{"x":{"diagram":"\ndigraph factorial {\n  rankdir=TB;\n  node [shape=circle, style=filled, fillcolor=lightblue];\n  edge [arrowhead=none];\n  \n  # Nós\n  mu [label=\"μ\"]\n  epsilon [label=\"ε\"]\n\n  # Relações\n  epsilon -> {A, B} -> mu;\n}\n","config":{"engine":"dot","options":null}},"evals":[],"jsHooks":[]}</script>

**Tradução para R:** O operador de cruzamento é `*`.
O modelo para `A` e `B` cruzados é:
`~ A * B`
que é expandido pelo R para:
`~ A + B + A:B`
]

**Portanto, ao desenhar o diagrama de Hasse para o seu delineamento experimental, você está, na verdade, especificando a fórmula correta do seu modelo estatístico.**

---

### Exemplo Prático: Delineamento em Blocos Completos Aleatorizados (RCBD)

Este é um exemplo clássico que ilustra o poder dos diagramas para escolher o modelo correto.

**Cenário Experimental:**
- Queremos testar o efeito de 3 **Tratamentos** (A, B, C) (nosso fator de interesse).
- Suspeitamos que há um gradiente de fertilidade no campo (uma fonte de variabilidade que não nos interessa, mas que pode mascarar o efeito do tratamento).
- Para controlar essa variabilidade, dividimos o campo em 4 **Blocos**. Cada bloco é uma área que consideramos homogênea internamente, mas pode ser diferente de outros blocos.
- Em cada bloco, aplicamos *todos* os 3 tratamentos a 3 unidades experimentais, de forma aleatória.
---

**Análise das Relações:**
- O fator de interesse é `Tratamento`.
- O fator de controle (ou "ruído") é `Bloco`.
- Como cada tratamento aparece em cada bloco, os fatores `Tratamento` e `Bloco` são **cruzados**.
- A interação `Bloco:Tratamento` existe? Sim, mas em um RCBD sem réplicas, ela está **confundida** com o erro experimental residual. A unidade experimental (`\(\epsilon\)`) é, na verdade, a combinação de um Bloco com um Tratamento.

---

### Diagrama de Hasse e Modelo para o Delineamento em Blocos (RCBD)


**Construindo o Diagrama:**
1.  A unidade experimental (`\(\epsilon\)`), que representa a variação `Bloco:Tratamento`, está no nível mais baixo.
2.  Acima dela, estão os fatores que a definem: `Bloco` e `Tratamento`.
3.  Como `Bloco` e `Tratamento` são cruzados, eles formam uma estrutura paralela.
4.  Ambos estão abaixo da média geral (`\(\mu\)`).

<div class="grViz html-widget html-fill-item" id="htmlwidget-0b9021b0c44d83d22e18" style="width:576px;height:180px;"></div>
<script type="application/json" data-for="htmlwidget-0b9021b0c44d83d22e18">{"x":{"diagram":"\ndigraph rcbd {\n  node [shape=box, style=rounded]\n  edge [arrowhead=none]\n  \n  # Nós\n  mu [label=\"μ\"]\n  bloco [label=\"Bloco\"]\n  trat [label=\"Tratamento\"]\n  epsilon [label=\"ε \n(Bloco:Tratamento)\", shape=ellipse]\n\n  # Relações\n  epsilon -> {bloco, trat} -> mu\n}\n","config":{"engine":"dot","options":null}},"evals":[],"jsHooks":[]}</script>
---

**Tradução para Modelo Estatístico:**

O diagrama mostra claramente dois fatores cruzados. Em um delineamento em blocos, geralmente não estamos interessados na interação bloco-tratamento (assumimos que ela não existe ou é pequena). Nosso objetivo é **remover a variabilidade devida aos Blocos** para conseguir enxergar o efeito dos Tratamentos com mais clareza.

**Fórmula do Modelo em R:**
O diagrama nos diz que `Bloco` e `Tratamento` são fatores cruzados. Como queremos estimar seus efeitos de forma aditiva (sem a interação), a fórmula correta é:

`Resposta ~ Bloco + Tratamento`

**O que este modelo faz?**
- `Tratamento`: Estima e testa o efeito do nosso fator de interesse.
- `Bloco`: Estima a variabilidade *entre* os blocos e a **remove** da soma de quadrados do resíduo.

Isso torna o termo de erro (`QM_Resíduo`) menor, o que aumenta o poder do nosso teste F para detectar diferenças entre os tratamentos. O diagrama de Hasse nos levou diretamente a este modelo, que é o padrão para a análise de um RCBD.

**Se estivéssemos interessados na interação, o modelo seria:**
`Resposta ~ Bloco * Tratamento` (mas não poderíamos estimar o erro residual separadamente sem réplicas).


---

### O Diagrama de Hasse como Ferramenta de Diagnóstico

Podemos usar o diagrama *antes* de realizar o experimento para verificar se o nosso delineamento é sólido.

**Cenário do Confundimento:** `Método de Ensino` confundido com `Professor`.
- O Prof. Silva SEMPRE usa o Método X.
- A Profa. Santos SEMPRE usa o Método Y.

**Análise Estrutural:**
Qualquer diferença observada entre os grupos pode ser devida ao `Professor` OU ao `Método`. Eles são indistinguíveis. Na linguagem de conjuntos e ordem parcial, eles são o mesmo elemento.

**Diagrama de Hasse do Delineamento Falho:**
<div class="grViz html-widget html-fill-item" id="htmlwidget-5075093a84a5b2d0a3e2" style="width:576px;height:180px;"></div>
<script type="application/json" data-for="htmlwidget-5075093a84a5b2d0a3e2">{"x":{"diagram":"\ndigraph confounded {\n  node [shape=circle, style=filled, fillcolor=lightcoral]\n  edge [arrowhead=none]\n  \n  # Nós confundidos em um só\n  conf [label=\"(Professor, Método)\"]\n  \n  # Relações\n  epsilon -> conf -> mu\n  \n  # Rótulos\n  mu [label = \"μ\"]; epsilon [label = \"ε\"]\n}\n","config":{"engine":"dot","options":null}},"evals":[],"jsHooks":[]}</script>

**Diagnóstico:** O diagrama mostra visualmente que não há como separar os efeitos. Se tivéssemos desenhado este diagrama durante a fase de planejamento, a falha seria óbvia e o experimento poderia ser corrigido (ex: fazendo ambos os professores usarem ambos os métodos, o que resultaria em um delineamento cruzado).
---
class: center, middle, inverse

## 3.6 a 3.8: Ajuste, Estimação e Teoria

---

### O Modelo em Forma Matricial: `\(y = X\beta + \epsilon\)`
A matriz `\(X\)` é a **representação matemática do seu delineamento experimental**.

### O Princípio de Mínimos Quadrados e as Equações Normais
O objetivo é encontrar `\(b\)` que minimiza `\(S(b) = (y - Xb)^T(y - Xb)\)`.
A solução é encontrada derivando `\(S(b)\)` em relação a `\(b\)` e igualando a zero:
$$ \frac{\partial S(b)}{\partial b} = -2X^T(y - Xb) = 0 \implies X^T y - X^T X b = 0 $$
O que nos leva às **Equações Normais**:
$$ (X^T X) b = X^T y $$

---

### Singularidade, Inversa Generalizada e Estimabilidade

A matriz `\(X^T X\)` é singular em modelos fatoriais devido à **sobreparametrização**. A solução `\(b\)` não é única.

**Solução:** `\(b = (X^T X)^- X^T y\)`, onde `\((X^T X)^-\)` é *qualquer* **inversa generalizada**.

**Implicação Profunda: Estimabilidade.**

Embora `\(b\)` não seja único, o vetor de valores preditos `\(\hat{y} = Xb = X(X^T X)^- X^T y = P_X y\)` **é único**, pois a matriz de projeção `\(P_X\)` é invariante à escolha da inversa generalizada.

Uma função `\(l^T \beta\)` é **estimável** se ela pode ser escrita como uma combinação linear dos valores médios esperados, `\(E(y_i)\)`. 

Matematicamente, `\(l^T\)` deve pertencer ao espaço-linha de `\(X\)`. Apenas estas funções têm estimativas únicas e interpretação científica.

---

## Teorema de Gauss-Markov e Modelo de Aitken

**Teorema de Gauss-Markov:** Se os erros `\(\epsilon\)` têm média zero, variância constante `\(\sigma^2\)` e não são correlacionados (`\(Var(\epsilon)=\sigma^2 I\)`), então o estimador de Mínimos Quadrados Ordinários (OLS) é o **BLUE** (Best Linear Unbiased Estimator) para qualquer função estimável `\(l^T \beta\)`.

**Modelo de Aitken:** E se os erros *não* forem "bem-comportados"? 

(`\(Var(\epsilon) = \sigma^2 H\)`, com `\(H \neq I\)`).
Neste caso, o estimador BLUE é o de **Mínimos Quadrados Generalizados (GLS)**:
$$ b_{GLS} = (X^T H^{-1} X)^{-} X^T H^{-1} y $$
Ele pondera as observações para dar menos peso às de maior variância.

---
class: center, middle, inverse

## 4. Análise de Variância e Inferência

(Seções 3.10 em diante)

---

## 3.10 A Geometria da Análise de Variância (ANOVA)

A ANOVA particiona a variabilidade total dos dados. A intuição geométrica é a mais poderosa: é uma aplicação do **Teorema de Pitágoras** em um espaço vetorial de `\(n\)` dimensões.

O vetor de dados `\(y\)` é decomposto em componentes **ortogonais**:
`$$y = \underbrace{P_{J_n} y}_{\text{Vetor Média}} + \underbrace{(P_X - P_{J_n})y}_{\text{Vetor de Efeitos}} + \underbrace{(I - P_X)y}_{\text{Vetor de Resíduos}}$$`
`$$y_{ajustado} = \bar{y} \mathbf{1} + \text{efeitos} + \text{resíduos}$$`

Como os vetores são ortogonais, a soma de suas "energias" (norma ao quadrado) se conserva:
`$$||y - \bar{y}\mathbf{1}||^2 = ||\text{efeitos}||^2 + ||\text{resíduos}||^2$$`
`$$SQ_{Total} = SQ_{Modelo} + SQ_{Resíduo}$$`

---
### Tabela de ANOVA (Corrigida pela Média)


| F.V. | G.L. (df) | S.Q. (Sum Sq) | Q.M. (Mean Sq) | F |
|:---|:---:|:---:|:---:|:---:|
| Tratamento | `\(t-1\)` | `\(SQ_{Trat}\)` | `\(SQ_{Trat}/(t-1)\)` | `\(QM_{Trat}/QM_{Res}\)` |
| Resíduo | `\(n-t\)` | `\(SQ_{Res}\)` | `\(SQ_{Res}/(n-t)\)` | |
| Total | `\(n-1\)` | `\(SQ_{Total}\)` | | |

- **QM (Quadrado Médio):** É uma estimativa da variância associada àquela fonte. `\(E(QM_{Res}) = \sigma^2\)`. `\(E(QM_{Trat}) = \sigma^2 + \frac{k}{t-1}\sum \tau_i^2\)`.
- **Estatística F:** Compara a variabilidade explicada pelo modelo com a variabilidade residual. Se `\(H_0\)` (não há efeito do tratamento) for verdadeira, `\(\sum \tau_i^2 = 0\)` e esperamos que `\(F \approx 1\)`.

---
### Exemplo Prático: ANOVA de um fator com `ggplot2`

**Cenário:** Testando 3 fertilizantes (A, B, C) na produção.

``` r
set.seed(123)
dados_fert &lt;- data.frame(
  Fertilizante = factor(rep(c("A", "B", "C"), each = 6)),
  Producao = c(rnorm(6, mean = 20, sd = 2), rnorm(6, mean = 25, sd = 2), rnorm(6, mean = 21, sd = 2))
)

# Visualização completa: pontos de dados + boxplot
p &lt;- ggplot(dados_fert, aes(x = Fertilizante, y = Producao, fill = Fertilizante)) +
  geom_boxplot(alpha = 0.6) +
  geom_jitter(width = 0.1, color = "black") + # Adiciona os pontos de dados
  labs(title = "Produção por Tipo de Fertilizante",
       subtitle = "Boxplots com dados individuais sobrepostos") +
  theme_minimal(base_size = 14) +
  theme(legend.position = "none")
```
---


``` r
p
```

&lt;img src="MATD48-04_files/figure-html/unnamed-chunk-15-1.png" style="display: block; margin: auto;" /&gt;
---
### Ajustando o Modelo e Gerando a Tabela ANOVA em R


``` r
modelo_fert &lt;- lm(Producao ~ Fertilizante, data = dados_fert); tabela_anova &lt;- anova(modelo_fert)
print(tabela_anova)
```

```
## Analysis of Variance Table
## 
## Response: Producao
##              Df Sum Sq Mean Sq F value   Pr(&gt;F)   
## Fertilizante  2 60.633 30.3167  6.9202 0.007425 **
## Residuals    15 65.713  4.3809                    
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
```

**Interpretando o Resultado Detalhadamente:**
1.  **Hipóteses:**
    - `\(H_0: \mu_A = \mu_B = \mu_C\)` (Os fertilizantes não têm efeito diferente).
    - `\(H_1:\)` Pelo menos uma média é diferente.
2.  **Estatística de Teste F:** O valor F de 14.19 indica que a variância *entre* os grupos é ~14 vezes maior que a variância *dentro* dos grupos.
3.  **p-valor:** A probabilidade de observar um F tão grande (ou maior) por puro acaso, *se a H₀ fosse verdadeira*, é de 0.00038.
4.  **Decisão e Conclusão:** Como p &lt; 0.05, rejeitamos `\(H_0\)`. Existem evidências estatísticas fortes para concluir que o tipo de fertilizante afeta a produção.

---
class: center, middle, inverse

## 3.11 Teoria Inferencial, Distribuições e Referências

---

### O Modelo Linear Normal e Suas Consequências

A premissa adicional de que os erros seguem uma distribuição Normal, `\(\epsilon \sim N(0, \sigma^2 I)\)`, é o que permite a inferência clássica (testes F, testes t, intervalos de confiança).

Sob esta premissa:
- `\(y \sim N(X\beta, \sigma^2 I)\)`.
- As Somas de Quadrados, que são formas quadráticas de vetores normais, seguem distribuições Qui-quadrado (`\(\chi^2\)`).
- A independência entre as Somas de Quadrados (garantida pelo Teorema de Cochran) permite a construção da estatística `\(F\)`.

---

### O Teorema de Cochran: A Grande Unificação

Para qualquer modelo linear (com fatores cruzados, aninhados, etc.), a soma de quadrados total pode ser particionada em componentes ortogonais.

$$ y^T(I-J_n)y = y^T A_1 y + y^T A_2 y + \dots + y^T A_p y $$

O **Teorema de Cochran** garante que, sob a premissa de normalidade e `\(H_0\)`:
1.  Cada termo `\(\frac{y^T A_i y}{\sigma^2}\)` segue uma distribuição `\(\chi^2_{k_i}\)`, onde `\(k_i = posto(A_i)\)` são os graus de liberdade.
2.  Todos esses termos são **mutuamente independentes**.

Este teorema é a fundação que justifica toda a tabela de ANOVA, permitindo-nos construir testes F válidos para cada linha da tabela.

---

### Referências e Leitura Complementar

Para um aprofundamento nos tópicos discutidos, as seguintes obras são referências clássicas na área de Modelos Lineares:

- **Searle, S. R. (1971). *Linear Models*.** Wiley.
  - *Um texto fundamental e matematicamente rigoroso sobre a teoria de modelos lineares, especialmente para dados desbalanceados.*

- **Scheffé, H. (1959). *The Analysis of Variance*.** Wiley.
  - *O trabalho clássico sobre ANOVA, com uma abordagem geométrica profunda.*

- **Christensen, R. (2011). *Plane Answers to Complex Questions: The Theory of Linear Models*.** Springer.
  - *Uma abordagem moderna e muito conceituada, que conecta a teoria com a prática computacional.*

- **Rao, C. R. (1973). *Linear Statistical Inference and Its Applications*.** Wiley.
  - *Uma referência abrangente sobre inferência estatística, com capítulos detalhados sobre a teoria de estimação em modelos lineares.*
```
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
  "highlightStyle": "github",
  "highlightLines": true,
  "countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
